本章将要介绍一个贯穿本书的框架，后续的算法设计与分析都是在这个框架中进行的。这一部分内容基本上是独立的,但也有对第 3 章和第 4 章中一些内容的引用（本章也包含几个求和的式子，附录A将给出如何求和）。

首先，我们考察求解第 1 章中引入的排序问题的插入排序算法。我们定义一种对于已经编写过计算机程序的读者来说应该熟悉的“伪代码”，并用它来表明我们将如何说明算法。然后，在说明了插入排序算法后，我们将证明该算法能正确地排序并分析其运行时间。这种分析引入了一种记号，该记号关注时间如何随着将被排序的项数而增加。在讨论完插入排序之后，我们引入用于算法设计的分治法并使用这种方法开发一个称为归并排序的算法。最后，我们分析归并排序的运行时间。

## 2.1 插入排序

我们的第一个算法（插入排序）求解第 1 章中引入的排序问题：

输入：$n$ 个数的一个序列 $\langle a_1, a_2, \cdots, a_n\rangle$ 。
输出：输入序列的一个排列 $\langle a_1^{\prime}, a_2^{\prime}, \cdots, a_n^{\prime}\rangle$, 满足 $a_1^{\prime} \leqslant a_2^{\prime} \leqslant \cdots \leqslant a_n^{\prime}$ 。

我们希望排序的数也称为关键词。虽然概念上我们在排序一个序列，但是输入是以 $n$ 个元素的数组的形式出现的。

本书中，我们通常将算法描述为用一种伪代码书写的程序，该伪代码在许多方面类似于C、C++、Java、Python或者JavaScript。如果你学过这些语言中的任何一种，那么在阅读我们的算法时应该没有困难。伪代码与真实的代码的区别在于，在伪代码中，我们使用最清晰、最简洁的表示方法来说明给定的算法。有时最清晰的表示方法是自然语言，所以如果你遇到一段自然语言嵌入在伪代码中就不要吃惊。伪代码与真正的代码的另一个区别是伪代码通常不关心软件工程的问题。为了更简洁地表达算法的本质，常常忽略数据抽象、模块化和错误处理的问题。

我们首先介绍插入排序，对于少量元素的排序，它是一个有效的算法。插入排序的工作方式像许多人排序一手扑克牌。开始时，我们的左手为空并且桌子上的牌面向下。然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较，如下图所示。拿在左手上的牌总是排序好的，原来这些牌是桌子上牌堆中顶部的牌。

![[2-1.svg]]
对于插入排序，我们将其伪代码过程命名为INSERTION-SORT，其中的参数是一个数组 $A[1..n]$，包含长度为 $n$ 的要排序的一个序列。（在代码中，$A$中元素的数目 $n$ 用 $A.length$ 来表示。）该算法原地排序输入的数：算法在数组 $A$ 中重排这些数，在任何时候，最多只有其中的常数个数字存储在数组外面。在过程 INSERTION-SORT 结束时，输入数组 $A$ 包含排序好的输出序列。

>INSERTION-SORT($A$)
>1  for $j=2$ to $A.length$
>2    $key=A[j]$
>3    // 将 $A[j]$ 插入到已排好序的子数组 $A[1..j-1]$
>4    $i=j-1$
>5    while $i>0$ and $A[i]>key$
>6      $A[i+1]=A[i]$
>7      $i=i-1$
>8    $A[i+1]=key$

### 循环不变式与插入排序的正确性

![[2-2.svg|600]]

==图2-2==：在数组 $A=\langle 5,2,4,6,1,3\rangle$上 INSERTION-SORT 的操作。数组下标出现在长方形的上方，数组位置中存储的值出现在长方形中。(a)~(e) 第 1~8 行 for 循环的迭代。每次迭代中，黑色的长方形保存取自 $A[j]$ 的关键字，在第 5 行的测试中将它与其左边的加阴影的长方形中的值进行比较。加阴影的箭头指出数组值在第 6 行向右移动一个位置，黑色的箭头指出在第 8 行关键字被移到的地方。 (f) 最终排序好的数组。

上图表明对$A=\langle 5,2, 4, 6, 1, 3\rangle$该算法如何工作。下标 $j$ 指出正被插入到手中的“当前牌”。在 for 循环（循环变量为$j$） 的每次迭代的开始，包含元素 $A[1..j-1]$ 的子数组构成了当前排序好的左手中的牌，剩余的子数组 $A[j+1..n]$ 对应于仍在桌子上的牌堆。事实上，元素 $A[1..j-1]$ 就是原来在位置 1 到 $j-1$ 的元素，但现在已按序排列。我们把 $A[1..j-1]$ 的这些性质形式地表示为一个循环不变式：

>在第 1～8 行的 for 循环的每次迭代开始时，子数组 $A[1..j-1]$ 由原来在 $A[1..j-1]$ 中的元素组成，但已按序排列。

循环不变式主要用来帮助我们理解算法的正确性。关千循环不变式，我们必须证明三条性质：

初始化：循环的第一次迭代之前，它为真。
保持：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。
终止：在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法是正确的。

当前两条性质成立时，在循环的每次迭代之前循环不变式为真。（当然，为了证明循环不变式在每次迭代之前保持为真，我们完全可以使用不同于循环不变式本身的其他已证实的事实。）注意，这类似于数学归纳法，其中为了证明某条性质成立，需要证明一个基本情况和一个归纳步。这里，证明第一次迭代之前不变式成立对应于基本情况，证明从一次迭代到下一次迭代不变式成立对应于归纳步。

第三条性质也许是最重要的，因为我们将使用循环不变式来证明正确性。通常，我们和导致循环终止的条件一起使用循环不变式。终止性不同于我们通常使用数学归纳法的做法，在归纳法中，归纳步是无限地使用的，这里当循环终止时，停止“归纳”。

让我们看看对于插入排序，如何证明这些性质成立。

初始化：首先证明在第一次循环迭代之前（当 $j=2$ 时），循环不变式成立。所以子数组 $A[1..j-1]$ 仅由单个元素 $A[1]$ 组成，实际上就是 $A[1]$ 中原来的元素。而且该子数组是排序好的（当然很平凡）。这表明第一次循环迭代之前循环不变式成立。

保持：其次处理第二条性质：证明每次迭代保持循环不变式。非形式化地，for 循环体的第 4~7 行将 $A[j-1]$ 、 $A[j-2]$ 、 $A[j-3]$ 等向右移动一个位置，直到找到 $A[j]$ 的适当位置，第 8 行将 $A[j]$ 的值插入该位置。这时子数组 $A[1..j]$ 由原来在 $A[1..j]$ 中的元素组成，但已按序排列。那么对 for 循环的下一次迭代增加 $j$ 将保持循环不变式。

第二条性质的一种更形式化的处理要求我们对第 5~7 行的 while 循环给出并证明一个循环不变式。然而，这里我们不愿陷入形式主义的困境，而是依赖以上非形式化的分析来证明第二条性质对外层循环成立。

终止：最后研究在循环终止时发生了什么。导致 for 循环终止的条件是 $j>A.length=n$ 。因为每次循环迭代 $j$ 增加 1，那么必有 $j=n+1$ 。在循环不变式的表述中将 $j$ 用 $n+1$ 代替，我们有：子数组 $A[1..n]$ 由原来在 $A[1..n]$ 中的元素组成，但已按序排列。注意到，子数组 $A[1..n]$ 就是整个数组，我们推断出整个数组已排序。因此算法正确。

在本章后面以及其他章中,我们将采用这种循环不变式的方法来证明算法的正确性。

### 伪代码中的一些约定

我们在伪代码中采用以下约定：

- 缩进表示块结构。例如，第 1 行开始的 for 循环体由第 2~8 行组成，第 5 行开始的 while 循环体包含第 6~7 行但不包含第 8 行。我们的缩进风格也适用于 if-else 语句。采用缩进来代替常规的块结构标志，如 begin 和 end 语句，可以大大提高代码的清晰性。
- while、for 与 repeat-until 等循环结构以及 if-else 等条件结构与 C、C++、Java、Python 和 JavaScript 中的那些结构具有类似的解释。不像某些出现于 C++、Java 和 JavaScript 中的情况，本书中在退出循环后，循环计数器保持其值。因此，紧接在一个 for 循环后，循环计数器的值就是第一个超出 for 循环界限的那个值。在证明插入排序的正确性时，我们使用了该性质。第 1 行的 for 循环头为 for $j = 2$ to $A.length$ ，所以，当该循环终止时，$j = A.length+1$ （或者等价地，$j=n+1$ 因为 $n= A.length$）。当一个 for 循环每次迭代增加其循环计数器时，我们使用关键词 to 。当一个 for 循环每次迭代减少其循环计数器时，我们使用关键词 downto 。当循环计数器以大于 1 的一个量改变时，该改变量跟在可选关键词 by 之后。
- 符号 “//” 表示该行后面部分是个注释。
- 形如 $i=j=e$ 的多重赋值将表达式 $e$ 的值赋给变量 $t$ 和 $j$ ；它应被处理成等价于赋值 $j=e$ 后跟着赋值 $i=j$ 。
- 变量（如 $i$ 、 $j$ 和 $key$） 是局部于给定过程的。若无显式说明，我们不使用全局变量。
- 数组元素通过 `数组名[下标]` 这样的形式来访问。例如，$A[i]$ 表示数组 $A$ 的第 $i$ 个元素。记号“..”用于表示数组中值的一个范围，这样，$A[1..j]$ 表示 $A$ 的一个子数组，它包含 $j$ 个元素 $A[1],A[2],\cdots,A[j]$ 。
- 复合数据通常被组织成对象，对象又由属性组成。我们使用许多面向对象编程语言中创建的句法来访问特定的属性：对象名后跟一个点再跟属性名。例如，数组可以看成是一个对象，它具有属性 $length$ ，表示数组包含多少元素，如 $A.length$ 就表示数组 $A$ 中的元素数目。
  
  我们把表示一个数组或对象的变量看做指向表示数组或对象的数据的一个指针。对于某个对象 $x$ 的所有属性 $f$ ，赋值 $y=x$ 导致 $y.f$ 等于 $x.f$。进一步，若现在置 $x.f=3$ ，则赋值后不但 $x.f$ 等于 3 ，而且 $y.f$ 也等于 3 。换句话说，在赋值 $y=x$ 后，$x$ 和 $y$ 指向相同的对象。
  
  我们的属性记号可以“串联”。例如，假设属性 $f$ 本身是指向某种类型的具有属性 $g$ 的对象的一个指针。那么记号 $x.f.g$ 被隐含地加括号成 $(x.f).g$ 。换句话说，如果已经赋值 $y=x.f$ ，那么 $x.f.g$ 与 $y.g$ 相同。
  
  有时，一个指针根本不指向任何对象。这时，我们赋给它特殊值 NIL 。
- 我们按值把参数传递给过程：被调用过程接收其参数自身的副本。如果它对某个参数赋值，调用过程看不到这种改变。当对象被传递时，指向表示对象数据的指针被复制，而对象的属性却未被复制。例如，如果 $x$ 是某个被调用过程的参数，在被调用过程中的赋值 $x=y$ 对调用过程是不可见的。然而，赋值 $x.f=3$ 却是可见的。类似地，数组通过指针来传递，结果指向数组的一个指针被传递，而不是整个数组，单个数组元素的改变对调用过程是可见的。
- 一个 return 语句立即将控制返回到调用过程的调用点。大多数 return 语句也将一个值传递回调用者。我们的伪代码与许多编程语言不同，因为我们允许在单一的 return 语句中返回多个值。
- 布尔运算符 “and” 和 “or” 都是短路求值的。也就是说，当求值表达式 “$x$ and $y$” 时，首先求值 $x$ 。如果 $x$ 求值为 FALSE ，那么整个表达式不可能求值为 TRUE ，所以不再求值 $y$ 。另外，如果 $x$ 求值为 TRUE ，那么就必须求值 $y$ 以确定整个表达式的值。类似地，对表达式 “$x$ or $y$” ，仅当 $x$ 求值为 FALSE 时，才求值表达式 $y$ 。短路的运算符使我们能书写像 “$x$ != NIL and x.f = y” 这样的布尔表达式，而不必担心当 $x$ 为 NIL 时我们试图求值 $x.f$ 将会发生什么情况。
- 关键字 error 表示因为已被调用的过程情况不对而出现了一个错误。调用过程负责处理该错误，所以我们不用说明将采取什么行动。

## 2.2 分析算法

分析算法的结果意味着预测算法需要的资源。虽然有时我们主要关心像内存、通信带宽或计算机硬件这类资源，但是通常我们想度量的是计算时间。一般来说，通过分析求解某个问题的几种候选算法，我们可以选出一种最有效的算法。这种分析可能指出不止一个可行的候选算法，但是在这个过程中，我们往往可以抛弃几个较差的算法。

在能够分析一个算法之前，我们必须有一个要使用的实现技术的模型，包括描述所用资源及其代价的模型。对本书的大多数章节，我们假定一种通用的单处理器计算模型随机访问机（random-access machine，RAM）来作为我们的实现技术，算法可以用计算机程序来实现。在 RAM 模型中，指令一条接一条地执行，没有并发操作。

严格地说，我们应该精确地定义 RAM 模型的指令及其代价。然而，这样做既乏味又对算法的设计与分析没有多大意义。我们还要注意不能滥用 RAM 模型。例如，如果一台 RAM 有一条排序指令，会怎样呢？这时，我们只用一条指令就能排序。这样的 RAM 是不现实的，因为真实的计算机并没有这样的指令。所以，我们的指导性意见是真实计算机如何设计，RAM 就如何设计。RAM 模型包含真实计算机中常见的指令：算术指令（如加法、减法、乘法、除法、取余、向下取整、向上取整）、数据移动指令（装入、存储、复制）和控制指令（条件与无条件转移、子程序调用与返回）。每条这样的指令所需时间都为常量。

RAM 模型中的数据类型有整数型和浮点实数型。虽然在本书中，我们一般不关心精度，但是在某些应用中，精度是至关重要的。我们还对每个数据字的规模假定一个范围。例如，当处理规模为 $n$ 的输入时，我们一般假定对某个大于等于 1 的常量 $c$ ，整数由 $c\lg n$ 位来表示。我们要求 $c$ 大于等于 1 ，这样每个字都可以保存 $n$ 的值，从而使我们能索引单个输入元素。我们限制 $c$ 为常量，这样字长就不会任意增长。（如果字长可以任意增长，我们就能在一个字中存储巨量的数据，并且其上的操作都在常量时间内进行，这种情况显然不现实。）

真实的计算机包含一些上面未列出的指令，这些指令代表了 RAM 模型中的一个灰色区域。例如，指数运算是一条常量时间的指令吗？一般情况下不是；当 $x$ 和 $y$ 都是实数时，计算 $x^y$ 需要若干条指令。然而，在受限情况下，指数运算又是一个常量时间的操作。许多计算机都有“左移”指令，它在常量时间内将一个整数的各位向左移 $k$ 位。在大多数计算机中，将一个整数的各位向左移一位等价于将该整数乘以 2 ，结果将一个整数的各位向左移 $k$ 位等价于将该整数乘以 $2^k$ 。所以，只要 $k$ 不大于一个计算机字中的位数，这样的计算机就可以由一条常量时间的指令来计算 $2^k$ 即将整数 1 向左移 $k$ 位。我们尽量避免 RAM 模型中这样的灰色区域，但是，当 $k$ 是一个足够小的正整数时，我们将把 $2^k$ 的计算看成一个常量时间的操作。

在 RAM 模型中，我们并不试图对当代计算机中常见的内存层次进行建模。也就是说，我们没有对高速缓存和虚拟内存进行建模。几种计算模型试图解释内存层次的影响，对真实计算机上运行的真实程序，这种影响有时是重大的。本书中的一些问题考查了内存层次的影响，但是本书的大部分分析将不考虑这些影响。与 RAM 模型相比，包含内存层次的模型要复杂得多，所以可能难于使用。此外，RAM 模型分析通常能够很好地预测实际计算机上的性能。

采用 RAM 模型即使分析一个简单的算法也可能是一个挑战。需要的数学工具可能包括组合数学、概率论、代数技巧，以及识别一个公式中最有意义的项的能力。因为对每个可能的输入，算法的行为可能不同，所以我们需要一种方法来以简单的、易于理解的公式的形式总结那样的行为。

即使我们通常只选择一种机器模型来分析某个给定的算法，在决定如何表达我们的分析时仍然面临许多选择。我们想要一种表示方法，它的书写和处理都比较简单，并能够表明算法资源需求的重要特征，同时能够抑制乏味的细节。

### 插入排序算法的分析

过程 INSERTION-SORT 需要的时间依赖于输入：排序 1000 个数比排序三个数需要更长的时间。此外，依据它们已被排序的程度，INSERTION-SORT 可能需要不同数量的时间来排序两个具有相同规模的输入序列。一般来说，算法需要的时间与输入的规模同步增长，所以通常把一个程序的运行时间描述成其输入规模的函数。为此，我们必须更仔细地定义术语“运行时间”和“输入规模”。

输入规模的最佳概念依赖于研究的问题。对许多问题，如排序或计算离散傅里叶变换，最自然的量度是输入中的项数，例如，待排序数组的规模 $n$ 。对其他许多问题，如两个整数相乘，输入规模的最佳量度是用通常的二进制记号表示输入所需的总位数。有时，用两个数而不是一个数来描述输入规模可能更合适。例如，若某个算法的输入是一个图，则输入规模可以用该图中的顶点数和边数来描述。对于研究的每个问题，我们将指出所使用的输入规模量度。

一个算法在特定输入上的运行时间是指执行的基本操作数或步数。定义“步”的概念以便尽量独立于机器是方便的。目前，让我们采纳以下观点，执行每行伪代码需要常量时间。虽然一行与另一行可能需要不同数量的时间，但是我们假定第 $i$ 行的每次执行需要时间 $c_i$ ，其中 $c_i$ 是一个常量。这个观点与 RAM 模型是一致的，并且也反映了伪代码在大多数真实计算机上如何实现。

在下面的讨论中，我们由繁到简地改进 INSERTION-SORT 运行时间的表达式，最初的公式使用所有语句代价 $c_i$ ，而最终的记号则更加简明、更容易处理，简单得多。这种较简单的记号比较易于用来判定一个算法是否比另一个更有效。

我们首先给出过程 INSERTION-SORT 中，每条语句的执行时间和执行次数。对 $j=2,3,\cdots,n$ ，其中 $n=A.length$ ， 假设 $t_j$ 表示对那个值 $j$ 第 5 行执行 while 循环测试的次数。当一个 for 或 while 循环按通常的方式（即由于循环头中的测试）退出时，执行测试的次数比执行循环体的次数多 1 。我们假定注释是不可执行的语句，所以它们不需要时间。

>INSERTION-SORT($A$)                           ==代价==      ==次数==
>1  for $j=2$ to $A.length$                       $c_1$        $n$
>2    $key=A[j]$                                $c_2$        $n-1$
>3    // 将 $A[j]$ 插入到已排好序的子数组 $A[1..j-1]$   $0$        $n-1$
>4    $i=j-1$                                 $c_4$        $n-1$
>5    while $i>0$ and $A[i]>key$                 $c_5$        $\sum_{j=2}^nt_j$
>6      $A[i+1]=A[i]$                           $c_6$        $\sum_{j=2}^n(t_j-1)$
>7      $i=i-1$                               $c_7$        $\sum_{j=2}^n(t_j-1)$
>8    $A[i+1]=key$                             $c_8$        $n-1$

该算法的运行时间是执行每条语句的运行时间之和。需要执行 $c_i$ 步且执行 $n$ 次的一条语句将贡献 $n$ 给总运行时间。为计算在具有 $n$ 个值的输入上 INSERTION-SORT 的运行时间 $T[n]$ ，我们将代价与次数列对应元素之积求和，得：
$$
\begin{aligned}
T(n)= & c_1 n+c_2(n-1)+c_4(n-1)+c_5 \sum_{j=2}^n t_j+c_6 \sum_{j=2}^n\left(t_j-1\right) \\
& +c_7 \sum_{j=2}^n\left(t_j-1\right)+c_8(n-1)
\end{aligned}
$$
即使对给定规模的输入，一个算法的运行时间也可能依赖于给定的是该规模下的哪个输入。例如，在 INSERTION-SORT 中，若输入数组已排好序，则出现最佳情况。这时，对每个 $j=2,3,\cdots,n$ ，我们发现在第 5 行，当 $i$ 取其初值 $j-1$ 时，有 $A[i]\le key$ 。从而对 $j=2,3,\cdots,n$ ，有 $t_j=1$ ，该最佳情况的运行时间为：
$$
\begin{aligned}
T(n) & =c_1 n+c_2(n-1)+c_4(n-1)+c_5(n-1)+c_8(n-1) \\
& =\left(c_1+c_2+c_4+c_5+c_8\right) n-\left(c_2+c_4+c_5+c_8\right)
\end{aligned}
$$
我们可以把该运行时间表示为 $an+b$ ，其中常量 $a$ 和 $b$ 依赖于语句代价 $c_i$ 。因此，它是 $n$ 的线性函数。

若输入数组已反向排序，即按递减序排好序，则导致最坏情况。我们必须将每个元素 $A[j]$ 与整个已排序子数组 $A[1..j-1]$ 中的每个元素进行比较，所以对 $j=2,3,\cdots,n$ ，有 $t_j=j$ 。注意到
$$
\sum_{j=2}^n=\frac{n(n+1)}{2}-1
$$
和
$$
\sum_{j=2}^n(j-1)=\frac{n(n-1)}{2}
$$
（对于如何求和，请参见附录A），我们发现在最坏情况下，INSERTION-SORT 的运行时间为
$$
\begin{aligned}
T(n)= & c_1 n+c_2(n-1)+c_4(n-1)+c_5\left(\frac{n(n+1)}{2}-1\right) \\
& +c_6\left(\frac{n(n-1)}{2}\right)+c_7\left(\frac{n(n-1)}{2}\right)+c_8(n-1) \\
= & \left(\frac{c_5}{2}+\frac{c_6}{2}+\frac{c_7}{2}\right) n^2+\left(c_1+c_2+c_4+\frac{c_5}{2}-\frac{c_6}{2}-\frac{c_7}{2}+c_8\right) n \\
& -\left(c_2+c_4+c_5+c_8\right)
\end{aligned}
$$
我们可以把该最坏情况运行时间表示为 $an^2+bn+c$ ，其中常量 $a$、$b$ 和 $c$ 又依赖于语句代价 $c_i$ 。因此，它是 $n$ 的二次函数。

虽然在以后的章节中我们将看到一些有趣的“随机化”算法，即使对固定的输入，其行为也可能变化，但是通常的情况是像插入排序那样，算法的运行时间对给定的输入是固定的。

### 最坏情况与平均情况分析

在分析插入排序时，我们既研究了最佳情况，其中输入数组已排好序，又研究了最坏情况，其中输入数组已反向排好序。然而，在本书的余下部分中，我们往往集中于只求最坏情况运行时间，即对规模为 $n$ 的任何输入，算法的最长运行时间。下面给出这样做的三点理由：

- 一个算法的最坏情况运行时间给出了任何输入的运行时间的一个上界。知道了这个界，就能确保该算法绝不需要更长的时间。我们不必对运行时间做某种复杂的猜测并可以期望它不会变得更坏。
- 对某些算法，最坏情况经常出现。例如，当在数据库中检索一条特定信息时，若该信息不在数据库中出现，则检索算法的最坏情况会经常出现。在某些应用中，对缺失信息的检索可能是频繁的。
- “平均情况”往往与最坏情况大致一样差。假定随机选择 $n$ 个数并应用插入排序。需要多长时间来确定在子数组 $A[1..j-1]$ 的什么位置插入元素 $A[j]$ ？平均来说，$A[1..j-1]$ 中的一半元素小于 $A[j]$ ，一半元素大于 $A[j]$ 。所以，平均来说，我们检查子数组 $A[1..j-1]$ 的一半，那么 $t_j$ 大约为 $j/2$ 。导致的平均情况运行时间结果像最坏情况运行时间一样，也是输入规模的一个二次函数。

在某些特定情况下，我们会对一个算法的平均情况运行时间感兴趣；贯穿于本书，我们将看到概率分析技术被用于各种算法。平均情况分析的范围有限，因为对于特定的问题，什么构成一种“平均”输入并不明显。我们常常假定给定规模的所有输入具有相同的可能性。实际上，该假设可能不成立，但是，有时可以使用随机化算法，它做出一些随机的选择，以允许进行概率分析并产生某个期望的运行时间。在第 5 章以及后续的其他几章中，我们将进一步探究随机化算法。

### 增长量级

我们使用某些简化的抽象来使过程 INSERTION-SORT 的分析更加容易。首先，通过使用常量 $c_i$ 表示这些代价来忽略每条语句的实际代价。其次，注意到这些常量也提供了比我们真正需要的要多的细节：把最坏情况运行时间表示为 $an^2+bn+c$ ， 其中常量 $a$ 、 $b$ 和 $c$ 依赖于语句代价 $c_i$ 。这样，我们不但忽略实际的语句代价，而且也忽略抽象的代价 $c_i$ 。

现在我们做出一种更简化的抽象：即我们真正感兴趣的运行时间的增长率或增长量级。所以我们只考虑公式中最重要的项（例如，$an^2$），因为当 $n$ 的值很大时，低阶项相对来说不太重要。我们也忽略最重要的项的常系数，因为对大的输入，在确定计算效率时常量因子不如增长率重要。对于插入排序，当我们忽略低阶项和最重要的项的常系数时，只剩下最重要的项中的因子 $n^2$ 。我们记插入排序具有最坏情况运行时间 $\Theta(n^2)$ (读作“theta $n$ 平方”)。本章非形式化地使用 $\Theta$ 记号，第 3 章将给出其精确定义。

如果一个算法的最坏情况运行时间具有比另一个算法更低的增长量级，那么我们通常认为前者比后者更有效。由于常量因子和低阶项，对于小的输入，运行时间具有较高增长量级的一个算法与运行时间具有较低增长量级的另一个算法相比，其可能需要较少的时间。但是对足够大的输入，例如，一个 $\Theta(n^2)$ 的算法在最坏情况下比另一个 $\Theta(n^3)$ 的算法要运行得更快。

## 2.3 设计算法

我们可以选择使用的算法设计技术有很多。插入排序使用了增量方法：在排序子数组 $A[1..j-1]$ 后，将单个元素 $A[j]$ 插入子数组的适当位置，产生排序好的子数组 $A[1..j]$ 。

本节我们考查另一种称为“分治法”的设计方法。第 4 章将更深入地探究该方法。我们将用分治法来设计一个排序算法，该算法的最坏情况运行时间比插入排序要少得多。分治算法的优点之一是，通过使用第 4 章介绍的技术往往很容易确定其运行时间。

### 2.3.1 分治法

许多有用的算法在结构上是递归的：为了解决一个给定的问题，算法一次或多次递归地调用其自身以解决紧密相关的若干子问题。这些算法典型地遵循分治法的思想：将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。

分治模式在每层递归时都有三个步骤：

分解原问题为若干子问题，这些子问题是原问题的规模较小的实例。
解决这些子问题，递归地求解各子问题。然而，若子问题的规模足够小，则直接求解。
合并这些子问题的解成原问题的解。

归井排序算法完全遵循分治模式。直观上其操作如下：

分解：分解待排序的 $n$ 个元素的序列成各具 $n/2$ 个元素的两个子序列。
解决：使用归并排序递归地排序两个子序列。
合并：合并两个已排序的子序列以产生已排序的答案。

当待排序的序列长度为 1 时,递归“开始回升”，在这种情况下不要做任何工作，因为长度为 1 的每个序列都已经排好序。

归并排序算法的关键操作是“合并”步骤中两个已排序序列的合并。我们通过调用一个辅助过程 MERGE$(A,p,q,r)$ 来完成合并，其中 $A$ 是一个数组，$p$ 、 $q$ 和 $r$ 是数组下标，满足 $p\le q<r$ 。该过程假设子数组 $A[p..q]$ 和 $A[q+1..r]$ 都已排好序。它合并这两个子数组形成单一的已排好序的子数组并代替当前的子数组 $A[p..r]$ 。

过程 MERGE 需要 $\Theta(n)$ 的时间，其中 $n=r-p+1$ 是待合并元素的总数。它按以下方式工作。回到我们玩扑克牌的例子，假设桌上有两堆牌面朝上的牌，每堆都已排序，最小的牌在顶上。我们希望把这两堆牌合并成单一的排好序的输出堆，牌面朝下地放在桌上。我们的基本步骤包括在牌面朝上的两堆牌的顶上两张牌中选取较小的一张，将该牌从其堆中移开（该堆的顶上将显露一张新牌）并牌面朝下地将该牌放置到输出堆。重复这个步骤，直到一个输入堆为空，这时，我们只是拿起剩余的输入堆并牌面朝下地将该堆放置到输出堆。因为我们只是比较顶上的两张牌，所以计算上每个基本步骤需要常量时间。因为我们最多执行 $n$ 个基本步骤，所以合并需要 $\Theta(n)$ 的时间。

下面的伪代码实现了上面的思想，但有一个额外的变化，以避免在每个基本步骤必须检查是否有堆为空。在每个堆的底部放置一张哨兵牌，它包含一个特殊的值，用于简化代码。这里，我们使用 $\infty$ 作为哨兵值，结果每当显露一张值为 $\infty$ 的牌，它不可能为较小的牌，除非两个堆都已显露出其哨兵牌。但是，一旦发生这种情况，所有非哨兵牌都已被放置到输出堆。因为我们事先知道刚好 $r-p+1$ 张牌将被放置到输出堆，所以一旦已执行 $r-p+1$ 个基本步骤，算法就可以停止。

>MERGE$(A,p,q,r)$
> 1  $n_1=q-p+1$
> 2  $n_2=r-q$
> 3  初始化两个新数组：$L[1..n_1+1]$ 和 $R[1..n_2+1]$
> 4  for $i=1$ to $n_1$
> 5      $L[i]=A[p+i-1]$
> 6  for $j=1$ to $n_2$
> 7      $R[j]=A[q+j]$
> 8  $L[n_1+1]=\infty$
> 9  $R[n_2+1]=\infty$
>10  $i=1$
>11  $j=1$
>12  for $k=p$ to $r$
>13    if $L[i]\le R[j]$
>14        $A[k]=L[i]$
>15        $i=i+1$
>16    else $A[k]=R[j]$
>17         $j=j+1$

![[2-3.svg|600]]
==图2-3== 当子数组 $A[9..16]$ 包含序列 $\langle 2, 4, 5, 7, 1, 2, 3, 6\rangle$ 时，调用 MERGE$(A, 9, 12, 16)$ 第 10~17 行的操作。在复制并插入哨兵后，数组 $L$ 包含 $\langle 2, 4, 5, 7, \infty\rangle$ ，数组 $R$ 包含 $\langle 1, 2, 3, 6, \infty\rangle$ 。 $A$ 中的浅阴影位置包含它们的最终值，$L$ 和 $R$ 中的浅阴影位置包含有待于被复制回 $A$ 的值。合在一起，浅阴影位置总是包含原来在 $A[9..16]$ 中的值和两个哨兵。$A$ 中的深阴影位置包含将被覆盖的值，$L$ 和 $R$ 中的深阴影位置包含已被复制回 $A$ 的值。(a)~(h)在第 12~17 行循环的每次迭代之前，数组 $A$ 、 $L$ 和 $R$ 以及它们各自的下标 $k$ 、 $i$ 和 $j$ 。(i) 终止时的数组与下标。这时，$A[9..16]$ 中的子数组已排好序，$L$ 和 $R$ 中的两个哨兵是这两个数组中仅有的两个未被复制回 $A$ 的元素。

过程 MERGE 的详细工作过程如下：第 1 行计算子数组 $A[p..q]$ 的长度 $n_1$ ，第 2 行计算子数组 $A[q+1..r]$ 的长度 $n_2$ 。在第 3 行，我们创建长度分别为 $n_1+1$ 和 $n_2+1$ 的数组 $L$ 和 $R$ （“左”和“右”)，每个数组中额外的位置将保存哨兵。第 4~5 行的 for 循环将子数组 $A[p..q]$ 复制到 $L[1..n_1]$ ，第 6~7 行的 for 循环将子数组 $A[q+1..r]$ 复制到 $R[1..n_2]$ 。第 8~9 行将哨兵放在数组 $L$ 和 $R$ 的末尾。第 10~17 行图示在上面的图中，通过维待以下循环不变式，执行 $r-p+1$ 个基本步骤：

>在开始第 12~17 行 for 循环的每次迭代时，子数组 $A[p..k-1]$ 按从小到大的顺序包含 $L[1..n_1+1]$ 和 $R[1..n_2+1]$ 中的 $k-p$ 个最小元素。进而，$L[i]$ 和 $R[j]$ 是各自所在数组中未被复制回数组 $A$ 的最小元素。

我们必须证明第 12~17 行 for 循环的第一次迭代之前该循环不变式成立，该循环的每次迭代保持该不变式，并且循环终止时，该不变式提供了一种有用的性质来证明正确性。

初始化：循环的第一次迭代之前，有 $k=p$ ，所以子数组 $A[p..k-1]$ 为空。这个空的子数组包含 $L$ 和 $R$ 的 $k-p=0$ 个最小元素。又因为 $i=j=1$ ，所以 $L[i]$ 和 $R[j]$ 都是各自所在数组中未被复制回数组 $A$ 的最小元素。
保持：为了理解每次迭代都维持循环不变式，首先假设 $L[i]\le R[j]$。这时，$L[i]$ 是未被复制回数组 $A$ 的最小元素。因为 $A[p..k-1]$ 包含 $k-p$ 个最小元素，所以在第 14 行将 $L[i]$ 复制到 $A[k]$ 之后，子数组 $A[p..k]$ 将包含 $k-p+1$ 个最小元素。增加 $k$ 的值（在 for 循环中更新）和 $t$ 的值（在第 15 行中）后，为下次迭代重新建立了该循环不变式。反之，若 $L[i]>R[j]$ ，则第 16~17 行执行适当的操作来维持该循环不变式。
终止：终止时 $k=r+1$ 。根据循环不变式，子数组 $A[p..k-1]$ 就是 $A[p..r]$ 且按从小到大的顺序包含 $L[1..n_1+1]$ 和 $R[1..n_2+1]$ 中的 $k-p=r-p+1$ 个最小元素。数组 $L$ 和 $R$ 一起包含 $n_1+n_2+2=r-p+3$ 个元素。除两个最大的元素以外，其他所有元素都已被复制回数组 $A$ ，这两个最大的元素就是哨兵。

为了理解过程 MERGE 的运行时间是 $\Theta(n)$ ，其中 $n=r-p+1$ ，注意到，第 1~3 行和第 8~11 行中的每行需要常量时间，第 4~7 行的 for 循环需要 $\Theta(n_1+n_2)=\Theta(n)$ 的时间。并且，第 12~17 行的 for 循环有 $n$ 次迭代，每次迭代需要常量时间。

现在我们可以把过程 MERGE 作为归并排序算法中的一个子程序来用。下面的过程 MERGE-SORT$(A, p, r)$ 排序子数组 $A[p..r]$ 中的元素。若 $p\ge r$ ，则该子数组最多有一个元素，所以已经排好序。否则，分解步骤简单地计算一个下标 $q$ ，将 $A[p..r]$ 分成两个子数组 $A[p..q]$ 和 $A[q+1..r]$ ，前者包含 $\lceil{n/2}\rceil$ 个元素,后者包含 $\lfloor{n/2}\rfloor$ 元素。

>MERGE-SORT$(A,p,r)$
>1  if $p<r$
>2      $q=\lfloor{(p+r)/2}\rfloor$
>3      MERGE-SORT$(A,p,q)$
>4      MERGE-SORT$(A,q+1,r)$
>5      MERGE$(A,p,q,r)$

为了排序整个序列 $A=\langle A[1],A[2],\cdots,A[n]\rangle$ ，我们执行初始调用 MERGE-SORT$(A,1,A.length)$ ，这里再次有 $A.length=n$ 。下面的图自底向上地说明了当 $n$ 为 2 的幂时该过程的操作。算法由以下操作组成：合并只含 1 项的序列对形成长度为 2 的排好序的序列，合并长度为 2 的序列对形成长度为 4 的排好序的序列，依此下去，直到长度为 $n/2$ 的两个序列被合并最终形成长度为 $n$ 的排好序的序列。

![[2-4.svg|600]]
图片说明：归并排序在数组 $A=\langle 5,2,4,7,1,3,2,6\rangle$ 上的操作。随着算法自底向上地推进，待合并的已排好序的各序列的长度不断增加。

### 2.3.2 分析分治算法

当一个算法包含对其自身的递归调用时，我们往往可以用递归方程或递归式来描述其运行时间，该方程根据在较小输入上的运行时间来描述在规模为 $n$ 的问题上的总运行时间。然后，我们可以使用数学工具来求解该递归式并给出算法性能的界。

分治算法运行时间的递归式来自基本模式的三个步骤。如前所述，我们假设 $T(n)$ 是规模为 $n$ 的一个问题的运行时间。若问题规模足够小，如对某个常量 $c,n\le c$ ，则直接求解需要常量时间，我们将其写作 $\Theta(1)$ 。假设把原问题分解成 $a$ 个子问题，每个子问题的规模是原问题的 $1/b$ 。（对归并排序，$a$ 和 $b$ 都为 2，然而，我们将看到在许多分治算法中，$a\neq b$ 。）为了求解一个规模为 $n/b$ 的子问题，需要 $T(n/b)$ 的时间，所以需要 $aT(n/b)$ 的时间来求解 $a$ 个子问题。如果分解问题成子问题需要时间 $D(n)$ ，合并子问题的解成原问题的解需要时间 $C(n)$ ，那么得到递归式：
$$
T(n)=\begin{cases}
\Theta(1)    & 若 n\le c \\
aT(n/b)+D(n)+C(n) & 其他
\end{cases}
$$
在第 4 章中，我们将看到如何求解这类常见的递归式。

#### 归并排序算法的分析

虽然 MERGE-SORT 的伪代码在元素的数量不是偶数时也能正确地工作，但是，如果假定原问题规模是 2 的幂，那么基于递归式的分析将被简化。这时每个分解步骤将产生规模刚好为 $n/2$ 的两个子序列。在第 4 章，我们将看到这个假设不影响递归式解的增长量级。

下面我们分析建立归并排序 $n$ 个数的最坏情况运行时间 $T(n)$ 的递归式。归并排序一个元素需要常量时间。当有 $n>1$ 个元素时，我们分解运行时间如下：

分解：分解步骤仅仅计算子数组的中间位置，需要常量时间，因此，$D(n)=\Theta(1)$ 。
解决：我们递归地求解两个规模均为 $n/2$ 的子问题，将贡献 $2T(n/2)$ 的运行时间。
合并：我们已经注意到在一个具有 $n$ 个元素的子数组上过程 MERGE 需要 $\Theta(n)$ 的时间，所以 $C(n)=\Theta(n)$ 。

当为了分析归并排序而把函数 $D(n)$ 与 $C(n)$ 相加时，我们是在把一个 $\Theta(n)$ 函数与另一个 $\Theta(1)$ 函数相加。相加的和是 $n$ 的一个线性函数，即 $\Theta(n)$ 。把它与来自“解决”步骤的项 $2T(n/2)$ 相加，将给出归并排序的最坏情况运行时间 $T(n)$ 的递归式：
$$
T(n)=\begin{cases}
\Theta(1) & 若 n=1 \\
2T(n/2)+\Theta(n) & 若 n>1
\end{cases} \quad\quad\quad\quad(2.1)
$$
在第 4 章，我们将看到“主定理”，可以用该定理来证明 $T(n)$ 为 $\Theta(n\lg n)$ ，其中 $\lg n$ 代表 $\log_2n$ 。因为对数函数比任何线性函数增长要慢，所以对足够大的输入，在最坏情况下，运行时间为 $\Theta(n\lg n)$ 的归并排序将优于运行时间为 $\Theta(n^2)$ 的插入排序。

为了直观地理解递归式 (2.1) 的解为什么是 $T(n)=\Theta(n\lg n)$ ，我们并不需要主定理。把递归式 (2.1) 重写为：
$$
T(n)=\begin{cases}
c & 若 n=1 \\
2T(n/2)+cn & 若 n>1
\end{cases} \quad\quad\quad\quad(2.2)
$$
其中常量 $c$ 代表求解规模为 1 的问题所需的时间以及在分解步骤与合并步骤处理每个数组元素所需的时间。

下图表示了如何求解递归式 (2.2) 。为方便起见，假设 $n$ 刚好是 2 的幂。图的 (a) 部分图示了 $T(n)$ ，它在 (b) 部分被扩展成一棵描绘递归式的等价树。项 $cn$ 是树根（在递归的顶层引起的代价），根的两棵子树是两个较小的递归式 $T(n/2)$ 。(c) 部分图示了通过扩展 $T(n/2)$ 再推进一步的
过程。在第二层递归中，两个子结点中每个引起的代价都是 $cn/2$ 。我们通过将其分解成由递归式所确定的它的组成部分来继续扩展树中的每个结点，直到问题规模下降到 1 ，每个子问题只要代价 $c$ 。(d) 部分图示了结果递归树。

![[2-5.svg|500]]

==图2-5== 对递归式 $T(n)=2T(n/2)+cn$ ，如何构造一棵递归树。(a)部分图示 $T(n)$ ，它在(b)~(d)部分被逐步扩展以形成递归树。在 (d) 部分，完全扩展了的递归树具有 $\lg n+1$ 层（即如图所示，其高度为 $\lg n$），每层将贡献总代价 $cn$ 。所以，总代价为 $cn\lg n+cn$ ，它就是 $\Theta(n\lg n)$

接着，我们把穿过这棵树的每层的所有代价相加。顶层具有总代价 $cn$ ，下一层具有总代价 $c(n/2)+c(n/2)=cn$ ，下一层的下一层具有总代价 $c(n/4)+c(n/4)+c(n/4)+c(n/4)=cn$ ，等等。一般来说，顶层之下的第 $i$ 层具有 $2^i$ 个结点，每个结点贡献代价 $c(n/2^i)$ ，因此，顶层之下的第 $i$ 层具有总代价 $2^ic(n/2^i)=cn$ 。底层具有 $n$ 个结点，每个结点贡献代价 $c$ ，该层的总代价为 $cn$ 。

图 2-5 中递归树的总层数为 $\lg n+1$ 。其中 $n$ 是叶数，对应于输入规模。一种非形式化的归纳论证将证明该断言。 $n=1$ 时出现基本情况，这时树只有一层。因为 $\lg 1=0$ ，所以有 $\lg n+1$ 给出了正确的层数。作为归纳假设，现在假设具有 $2^i$ 个叶的递归树的层数为 $\lg 2^i+1=i+1$ （因为对 $i$ 的任何值都有 $\lg 2^i=i$ ）。因为我们假设输入规模是 2 的幂，所以下一个要考虑的输入规模是 $2^{i+1}$ 。具有 $n=2^{i+1}$ 个叶的一棵树比具有 $2^i$ 个叶的一棵树要多一层，所以其总层数为 $(i+1)+1=\lg 2^{i+1}+1$ 。

为了计算递归式 (2.2) 表示的总代价，我们只要把各层的代价加起来。递归树具有 $\lg n+1$ 层，每层的代价均为 $cn$ ，所以总代价为 $cn(\lg n+1) = cn\lg n+cn$ 。忽略低阶项和常量 $c$ 便给出了期望的结果 $\Theta(n\lg n)$ 。

